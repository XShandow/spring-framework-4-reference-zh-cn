### 2.3.2 Logging 日志

Logging is a very important dependency for Spring because\_a\)\_it is the only mandatory external dependency,\_b\)\_everyone likes to see some output from the tools they are using, and\_c\)\_Spring integrates with lots of other tools all of which have also made a choice of logging dependency. One of the goals of an application developer is often to have unified logging configured in a central place for the whole application, including all external components. This is more difficult than it might have been since there are so many choices of logging framework.

The mandatory logging dependency in Spring is the Jakarta Commons Logging API \(JCL\). We compile against JCL and we also make JCL`Log`objects visible for classes that extend the Spring Framework. It’s important to users that all versions of Spring use the same logging library: migration is easy because backwards compatibility is preserved even with applications that extend Spring. The way we do this is to make one of the modules in Spring depend explicitly on`commons-logging`\(the canonical implementation of JCL\), and then make all the other modules depend on that at compile time. If you are using Maven for example, and wondering where you picked up the dependency on`commons-logging`, then it is from Spring and specifically from the central module called`spring-core`.

The nice thing about`commons-logging`is that you don’t need anything else to make your application work. It has a runtime discovery algorithm that looks for other logging frameworks in well known places on the classpath and uses one that it thinks is appropriate \(or you can tell it which one if you need to\). If nothing else is available you get pretty nice looking logs just from the JDK \(java.util.logging or JUL for short\). You should find that your Spring application works and logs happily to the console out of the box in most situations, and that’s important.

#### Using Log4j 1.2 or 2.x

> Log4j 1.2 is EOL in the meantime. Also, Log4j 2.3 is the last Java 6 compatible release, with newer Log4j 2.x releases requiring Java 7+.

Many people use[Log4j](https://logging.apache.org/log4j)as a logging framework for configuration and management purposes. It is efficient and well-established, and in fact it is what we use at runtime when we build Spring. Spring also provides some utilities for configuring and initializing Log4j, so it has an optional compile-time dependency on Log4j in some modules.

To make Log4j 1.2 work with the default JCL dependency \(`commons-logging`\) all you need to do is put Log4j on the classpath, and provide it with a configuration file \(`log4j.properties`or`log4j.xml`in the root of the classpath\). So for Maven users this is your dependency declaration:

```
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>4.3.11.RELEASE</version>
    </dependency>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>
</dependencies>
```

And here’s a sample log4j.properties for logging to the console:

```
log4j.rootCategory=INFO, stdout

log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %t %c{2}:%L - %m%n

log4j.category.org.springframework.beans.factory=DEBUG
```

To use Log4j 2.x with JCL, all you need to do is put Log4j on the classpath and provide it with a configuration file \(`log4j2.xml`,`log4j2.properties`, or other[supported configuration formats](https://logging.apache.org/log4j/2.x/manual/configuration.html)\). For Maven users, the minimal dependencies needed are:

```
<dependencies>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-core</artifactId>
        <version>2.6.2</version>
    </dependency>
    <dependency>
        <groupId>org.apache.logging.log4j</groupId>
        <artifactId>log4j-jcl</artifactId>
        <version>2.6.2</version>
    </dependency>
</dependencies>
```

If you also wish to enable SLF4J to delegate to Log4j, e.g. for other libraries which use SLF4J by default, the following dependency is also needed:

```
<dependencies>
  <dependency>
    <groupId>org.apache.logging.log4j</groupId>
    <artifactId>log4j-slf4j-impl</artifactId>
    <version>2.6.2</version>
  </dependency>
</dependencies>
```

Here is an example`log4j2.xml`for logging to the console:

```
<?xml version="1.0" encoding="UTF-8"?>
<Configuration status="WARN">
  <Appenders>
    <Console name="Console" target="SYSTEM_OUT">
      <PatternLayout pattern="%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n"/>
    </Console>
  </Appenders>
  <Loggers>
    <Logger name="org.springframework.beans.factory" level="DEBUG"/>
    <Root level="error">
      <AppenderRef ref="Console"/>
    </Root>
  </Loggers>
</Configuration>
```

#### Avoiding Commons Logging

Unfortunately, the runtime discovery algorithm in the standard`commons-logging`API, while convenient for the end-user, can be problematic. If you’d like to avoid JCL’s standard lookup, there are basically two ways to switch it off:

1. Exclude the dependency from the `spring-core` module \(as it is the only module that explicitly depends on `commons-logging`\)
2. Depend on a special `commons-logging` dependency that replaces the library with an empty jar \(more details can be found in the [SLF4J FAQ](http://slf4j.org/faq.html#excludingJCL)\)

To exclude commons-logging, add the following to your`dependencyManagement`section:

```
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>4.3.11.RELEASE</version>
        <exclusions>
            <exclusion>
                <groupId>commons-logging</groupId>
                <artifactId>commons-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
</dependencies>
```

Now this application is currently broken because there is no implementation of the JCL API on the classpath, so to fix it a new one has to be provided. In the next section we show you how to provide an alternative implementation of JCL using SLF4J.

#### Using SLF4J with Log4j or Logback

The Simple Logging Facade for Java \([SLF4J](http://www.slf4j.org/)\) is a popular API used by other libraries commonly used with Spring. It is typically used with[Logback](https://logback.qos.ch/)which is a native implementation of the SLF4J API.

SLF4J provides bindings to many common logging frameworks, including Log4j, and it also does the reverse: bridges between other logging frameworks and itself. So to use SLF4J with Spring you need to replace the`commons-logging`dependency with the SLF4J-JCL bridge. Once you have done that then logging calls from within Spring will be translated into logging calls to the SLF4J API, so if other libraries in your application use that API, then you have a single place to configure and manage logging.

A common choice might be to bridge Spring to SLF4J, and then provide explicit binding from SLF4J to Log4j. You need to supply several dependencies \(and exclude the existing`commons-logging`\): the JCL bridge, the SLF4j binding to Log4j, and the Log4j provider itself. In Maven you would do that like this

```
<dependencies>
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-core</artifactId>
        <version>4.3.11.RELEASE</version>
        <exclusions>
            <exclusion>
                <groupId>commons-logging</groupId>
                <artifactId>commons-logging</artifactId>
            </exclusion>
        </exclusions>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>jcl-over-slf4j</artifactId>
        <version>1.7.21</version>
    </dependency>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>slf4j-log4j12</artifactId>
        <version>1.7.21</version>
    </dependency>
    <dependency>
        <groupId>log4j</groupId>
        <artifactId>log4j</artifactId>
        <version>1.2.17</version>
    </dependency>
</dependencies>
```

A more common choice amongst SLF4J users, which uses fewer steps and generates fewer dependencies, is to bind directly to[Logback](http://logback.qos.ch/). This removes the extra binding step because Logback implements SLF4J directly, so you only need to depend on just two libraries, namely`jcl-over-slf4j`and`logback`\):

```
<dependencies>
    <dependency>
        <groupId>org.slf4j</groupId>
        <artifactId>jcl-over-slf4j</artifactId>
        <version>1.7.21</version>
    </dependency>
    <dependency>
        <groupId>ch.qos.logback</groupId>
        <artifactId>logback-classic</artifactId>
        <version>1.1.7</version>
    </dependency>
</dependencies>
```

#### Using JUL \(java.util.logging\)

Commons Logging will delegate to`java.util.logging`by default, provided that no Log4j is detected on the classpath. So there is no special dependency to set up: just use Spring with no external dependency for log output to`java.util.logging`, either in a standalone application \(with a custom or default JUL setup at the JDK level\) or with an application server’s log system \(and its system-wide JUL setup\).

#### Commons Logging on WebSphere

Spring applications may run on a container that itself provides an implementation of JCL, e.g. IBM’s WebSphere Application Server \(WAS\). This does not cause issues per se but leads to two different scenarios that need to be understood:

In a "parent first" ClassLoader delegation model \(the default on WAS\), applications will always pick up the server-provided version of Commons Logging, delegating to the WAS logging subsystem \(which is actually based on JUL\). An application-provided variant of JCL, whether standard Commons Logging or the JCL-over-SLF4J bridge, will effectively be ignored, along with any locally included log provider.

With a "parent last" delegation model \(the default in a regular Servlet container but an explicit configuration option on WAS\), an application-provided Commons Logging variant will be picked up, enabling you to set up a locally included log provider, e.g. Log4j or Logback, within your application. In case of no local log provider, regular Commons Logging will delegate to JUL by default, effectively logging to WebSphere’s logging subsystem like in the "parent first" scenario.

All in all, we recommend deploying Spring applications in the "parent last" model since it naturally allows for local providers as well as the server’s log subsystem.

