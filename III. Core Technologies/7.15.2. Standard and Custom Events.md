### 7.15.2 Standard and Custom Events

Event handling in the`ApplicationContext`is provided through the`ApplicationEvent`class and`ApplicationListener`interface. If a bean that implements the`ApplicationListener`interface is deployed into the context, every time an`ApplicationEvent`gets published to the`ApplicationContext`, that bean is notified. Essentially, this is the standard_Observer_design pattern.

> As of Spring 4.2, the event infrastructure has been significantly improved and offer an[annotation-based model](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#context-functionality-events-annotation)as well as the ability to publish any arbitrary event, that is an object that does not necessarily extend from`ApplicationEvent`. When such an object is published we wrap it in an event for you. |

Spring provides the following standard events:



**Table 7.7. Built-in Events**

| Event | Explanation |
| :--- | :--- |
| `ContextRefreshedEvent` | Published when the`ApplicationContext`is initialized or refreshed, for example, using the`refresh()`method on the`ConfigurableApplicationContext`interface. "Initialized" here means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the`ApplicationContext`object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen`ApplicationContext`actually supports such "hot" refreshes. For example,`XmlWebApplicationContext`supports hot refreshes, but`GenericApplicationContext`does not. |
| `ContextStartedEvent` | Published when the`ApplicationContext`is started, using the`start()`method on the`ConfigurableApplicationContext`interface. "Started" here means that all`Lifecycle`beans receive an explicit start signal. Typically this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart , for example, components that have not already started on initialization. |
| `ContextStoppedEvent` | Published when the`ApplicationContext`is stopped, using the`stop()`method on the`ConfigurableApplicationContext`interface. "Stopped" here means that all`Lifecycle`beans receive an explicit stop signal. A stopped context may be restarted through a`start()`call. |
| `ContextClosedEvent` | Published when the`ApplicationContext`is closed, using the`close()`method on the`ConfigurableApplicationContext`interface. "Closed" here means that all singleton beans are destroyed. A closed context reaches its end of life; it cannot be refreshed or restarted. |
| `RequestHandledEvent` | A web-specific event telling all beans that an HTTP request has been serviced. This event is published_after_the request is complete. This event is only applicable to web applications using Spring’s`DispatcherServlet`. |

  


You can also create and publish your own custom events. This example demonstrates a simple class that extends Spring’s`ApplicationEvent`base class:

```
public class BlackListEvent extends ApplicationEvent {

    private final String address;
    private final String test;

    public BlackListEvent(Object source, String address, String test) {
        super(source);
        this.address = address;
        this.test = test;
    }

    // accessor and other methods...

}
```

To publish a custom`ApplicationEvent`, call the`publishEvent()`method on an`ApplicationEventPublisher`. Typically this is done by creating a class that implements`ApplicationEventPublisherAware`and registering it as a Spring bean. The following example demonstrates such a class:

```
public class EmailService implements ApplicationEventPublisherAware {

    private List<String> blackList;
    private ApplicationEventPublisher publisher;

    public void setBlackList(List<String> blackList) {
        this.blackList = blackList;
    }

    public void setApplicationEventPublisher(ApplicationEventPublisher publisher) {
        this.publisher = publisher;
    }

    public void sendEmail(String address, String text) {
        if (blackList.contains(address)) {
            BlackListEvent event = new BlackListEvent(this, address, text);
            publisher.publishEvent(event);
            return;
        }
        // send email...
    }

}
```

At configuration time, the Spring container will detect that`EmailService`implements`ApplicationEventPublisherAware`and will automatically call`setApplicationEventPublisher()`. In reality, the parameter passed in will be the Spring container itself; you’re simply interacting with the application context via its`ApplicationEventPublisher`interface.

To receive the custom`ApplicationEvent`, create a class that implements`ApplicationListener`and register it as a Spring bean. The following example demonstrates such a class:

```
public class BlackListNotifier implements ApplicationListener<BlackListEvent> {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    public void onApplicationEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }

}
```

Notice that`ApplicationListener`is generically parameterized with the type of your custom event,`BlackListEvent`. This means that the`onApplicationEvent()`method can remain type-safe, avoiding any need for downcasting. You may register as many event listeners as you wish, but note that by default event listeners receive events synchronously. This means the`publishEvent()`method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, refer to the javadoc for Spring’s`ApplicationEventMulticaster`interface.

The following example shows the bean definitions used to register and configure each of the classes above:

```
<bean id="emailService" class="example.EmailService">
    <property name="blackList">
        <list>
            <value>known.spammer@example.org</value>
            <value>known.hacker@example.org</value>
            <value>john.doe@example.org</value>
        </list>
    </property>
</bean>

<bean id="blackListNotifier" class="example.BlackListNotifier">
    <property name="notificationAddress" value="blacklist@example.org"/>
</bean>
```

Putting it all together, when the`sendEmail()`method of the`emailService`bean is called, if there are any emails that should be blacklisted, a custom event of type`BlackListEvent`is published. The`blackListNotifier`bean is registered as an`ApplicationListener`and thus receives the`BlackListEvent`, at which point it can notify appropriate parties.

> Spring’s eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately-maintained[Spring Integration](http://projects.spring.io/spring-integration/)project provides complete support for building lightweight,[pattern-oriented](http://www.enterpriseintegrationpatterns.com/), event-driven architectures that build upon the well-known Spring programming model. |

#### Annotation-based Event Listeners

As of Spring 4.2, an event listener can be registered on any public method of a managed bean via the`EventListener`annotation. The`BlackListNotifier`can be rewritten as follows:

```
public class BlackListNotifier {

    private String notificationAddress;

    public void setNotificationAddress(String notificationAddress) {
        this.notificationAddress = notificationAddress;
    }

    @EventListener
    public void processBlackListEvent(BlackListEvent event) {
        // notify appropriate parties via notificationAddress...
    }

}
```

As you can see above, the method signature once again declares the event type it listens to, but this time with a flexible name and without implementing a specific listener interface. The event type can also be narrowed through generics as long as the actual event type resolves your generic parameter in its implementation hierarchy.

If your method should listen to several events or if you want to define it with no parameter at all, the event type\(s\) can also be specified on the annotation itself:

```
@EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class})
public void handleContextStart() {
    ...
}
```

It is also possible to add additional runtime filtering via the`condition`attribute of the annotation that defines a[`SpEL`expression](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#expressions)that should match to actually invoke the method for a particular event.

For instance, our notifier can be rewritten to be only invoked if the`test`attribute of the event is equal to`foo`:

```
@EventListener(condition = "#blEvent.test == 'foo'")
public void processBlackListEvent(BlackListEvent blEvent) {
    // notify appropriate parties via notificationAddress...
}
```

Each`SpEL`expression evaluates again a dedicated context. The next table lists the items made available to the context so one can use them for conditional event processing:



**Table 7.8. Event SpEL available metadata**

| Name | Location | Description | Example |
| :--- | :--- | :--- | :--- |
| Event | root object | The actual`ApplicationEvent` | `#root.event` |
| Arguments array | root object | The arguments \(as array\) used for invoking the target | `#root.args[0]` |
| _Argument name_ | evaluation context | Name of any of the method arguments. If for some reason the names are not available \(e.g. no debug information\), the argument names are also available under the`#a<#arg>`where_\#arg_stands for the argument index \(starting from 0\). | `#blEvent`or`#a0`\(one can also use`#p0`or`#p<#arg>`notation as an alias\). |

  


Note that`#root.event`allows you to access to the underlying event, even if your method signature actually refers to an arbitrary object that was published.

If you need to publish an event as the result of processing another, just change the method signature to return the event that should be published, something like:

```
@EventListener
public ListUpdateEvent handleBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress and
    // then publish a ListUpdateEvent...
}
```

> This feature is not supported for[asynchronous listeners](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#context-functionality-events-async). |

This new method will publish a new`ListUpdateEvent`for every`BlackListEvent`handled by the method above. If you need to publish several events, just return a`Collection`of events instead.

#### Asynchronous Listeners

If you want a particular listener to process events asynchronously, simply reuse the[regular`@Async`support](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#scheduling-annotation-support-async):

```
@EventListener
@Async
public void processBlackListEvent(BlackListEvent event) {
    // BlackListEvent is processed in a separate thread
}
```

Be aware of the following limitations when using asynchronous events:

1. If the event listener throws an  `Exception` it will not be propagated to the caller, check  `AsyncUncaughtExceptionHandler`for more details.
2. Such event listener cannot send replies. If you need to send another event as the result of the processing, inject `ApplicationEventPublisher` to send the event manually.

#### Ordering Listeners

If you need the listener to be invoked before another one, just add the`@Order`annotation to the method declaration:

```
@EventListener
@Order(42)
public void processBlackListEvent(BlackListEvent event) {
    // notify appropriate parties via notificationAddress...
}
```

#### Generic Events

You may also use generics to further define the structure of your event. Consider an`EntityCreatedEvent<T>`where`T`is the type of the actual entity that got created. You can create the following listener definition to only receive`EntityCreatedEvent`for a`Person`:

```
@EventListener
public void onPersonCreated(EntityCreatedEvent<Person> event) {
    ...
}
```

Due to type erasure, this will only work if the event that is fired resolves the generic parameter\(s\) on which the event listener filters on \(that is something like`class PersonCreatedEvent extends EntityCreatedEvent<Person> { …​ }`\).

In certain circumstances, this may become quite tedious if all events follow the same structure \(as it should be the case for the event above\). In such a case, you can implement`ResolvableTypeProvider`to_guide_the framework beyond what the runtime environment provides:

```
public class EntityCreatedEvent<T>
        extends ApplicationEvent implements ResolvableTypeProvider {

    public EntityCreatedEvent(T entity) {
        super(entity);
    }

    @Override
    public ResolvableType getResolvableType() {
        return ResolvableType.forClassWithGenerics(getClass(),
                ResolvableType.forInstance(getSource()));
    }
}
```

> This works not only for`ApplicationEvent`but any arbitrary object that you’d send as an event. |



