### 7.12.3 Using the @Bean annotation

`@Bean`is a method-level annotation and a direct analog of the XML`<bean/>`element. The annotation supports some of the attributes offered by`<bean/>`, such as:[init-method](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-initializingbean),[destroy-method](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-lifecycle-disposablebean),[autowiring](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-autowire)and`name`.

You can use the`@Bean`annotation in a`@Configuration`-annotated or in a`@Component`-annotated class.

#### Declaring a bean

To declare a bean, simply annotate a method with the`@Bean`annotation. You use this method to register a bean definition within an`ApplicationContext`of the type specified as the method’s return value. By default, the bean name will be the same as the method name. The following is a simple example of a`@Bean`method declaration:

```
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl();
    }

}
```

The preceding configuration is exactly equivalent to the following Spring XML:

```
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

Both declarations make a bean named`transferService`available in the`ApplicationContext`, bound to an object instance of type`TransferServiceImpl`:

```
transferService -
>
 com.acme.TransferServiceImpl
```

#### Bean dependencies

A`@Bean`annotated method can have an arbitrary number of parameters describing the dependencies required to build that bean. For instance if our`TransferService`requires an`AccountRepository`we can materialize that dependency via a method parameter:

```
@Configuration
public class AppConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }

}
```

The resolution mechanism is pretty much identical to constructor-based dependency injection, see[the relevant section](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-constructor-injection)for more details.

#### Receiving lifecycle callbacks

Any classes defined with the`@Bean`annotation support the regular lifecycle callbacks and can use the`@PostConstruct`and`@PreDestroy`annotations from JSR-250, see[JSR-250 annotations](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-postconstruct-and-predestroy-annotations)for further details.

The regular Spring[lifecycle](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-nature)callbacks are fully supported as well. If a bean implements`InitializingBean`,`DisposableBean`, or`Lifecycle`, their respective methods are called by the container.

The standard set of`*Aware`interfaces such as[BeanFactoryAware](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-beanfactory),[BeanNameAware](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-aware),[MessageSourceAware](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#context-functionality-messagesource),[ApplicationContextAware](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-aware), and so on are also fully supported.

The`@Bean`annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML’s`init-method`and`destroy-method`attributes on the`bean`element:

```
public class Foo {
    public void init() {
        // initialization logic
    }
}

public class Bar {
    public void cleanup() {
        // destruction logic
    }
}

@Configuration
public class AppConfig {

    @Bean(initMethod = "init")
    public Foo foo() {
        return new Foo();
    }

    @Bean(destroyMethod = "cleanup")
    public Bar bar() {
        return new Bar();
    }

}
```

> By default, beans defined using Java config that have a public`close`or`shutdown`method are automatically enlisted with a destruction callback. If you have a public`close`or`shutdown`method and you do not wish for it to be called when the container shuts down, simply add`@Bean(destroyMethod="")`to your bean definition to disable the default`(inferred)`mode.You may want to do that by default for a resource that you acquire via JNDI as its lifecycle is managed outside the application. In particular, make sure to always do it for a`DataSource`as it is known to be problematic on Java EE application servers.


```
@Bean(destroyMethod="")
public DataSource dataSource() throws NamingException {
    return (DataSource) jndiTemplate.lookup("MyDS");
}
```


> Also, with`@Bean`methods, you will typically choose to use programmatic JNDI lookups: either using Spring’s`JndiTemplate`/`JndiLocatorDelegate`helpers or straight JNDI`InitialContext`usage, but not the`JndiObjectFactoryBean`variant which would force you to declare the return type as the`FactoryBean`type instead of the actual target type, making it harder to use for cross-reference calls in other`@Bean`methods that intend to refer to the provided resource here. |

Of course, in the case of`Foo`above, it would be equally as valid to call the`init()`method directly during construction:

```
@Configuration
public
class
 AppConfig {
    
@Bean
public
 Foo foo() {
        Foo foo = 
new
 Foo();
        foo.init();
        
return
 foo;
    }

    
// ...


}
```

| ![](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/tip.png "\[Tip\]") |
| :--- |
| When you work directly in Java, you can do anything you like with your objects and do not always need to rely on the container lifecycle! |

#### Specifying bean scope

##### Using the @Scope annotation

You can specify that your beans defined with the`@Bean`annotation should have a specific scope. You can use any of the standard scopes specified in the[Bean Scopes](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes)section.

The default scope is`singleton`, but you can override this with the`@Scope`annotation:

```
@Configuration
public
class
 MyConfiguration {

    
@Bean
@Scope("prototype")
public
 Encryptor encryptor() {
        
// ...

    }

}
```

##### @Scope and scoped-proxy

Spring offers a convenient way of working with scoped dependencies through[scoped proxies](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes-other-injection). The easiest way to create such a proxy when using the XML configuration is the`<aop:scoped-proxy/>`element. Configuring your beans in Java with a @Scope annotation offers equivalent support with the proxyMode attribute. The default is no proxy \(`ScopedProxyMode.NO`\), but you can specify`ScopedProxyMode.TARGET_CLASS`or`ScopedProxyMode.INTERFACES`.

If you port the scoped proxy example from the XML reference documentation \(see preceding link\) to our`@Bean`using Java, it would look like the following:

```
// an HTTP Session-scoped bean exposed as a proxy
@Bean
@SessionScope
public
 UserPreferences userPreferences() {
    
return
new
 UserPreferences();
}


@Bean
public
 Service userService() {
    UserService service = 
new
 SimpleUserService();
    
// a reference to the proxied userPreferences bean

    service.setUserPreferences(userPreferences());
    
return
 service;
}
```

#### Customizing bean naming

By default, configuration classes use a`@Bean`method’s name as the name of the resulting bean. This functionality can be overridden, however, with the`name`attribute.

```
@Configuration
public
class
 AppConfig {

    
@Bean(name = "myFoo")
public
 Foo foo() {
        
return
new
 Foo();
    }

}
```

#### Bean aliasing

As discussed in[Section 7.3.1, “Naming beans”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-beanname), it is sometimes desirable to give a single bean multiple names, otherwise known as_bean aliasing_. The`name`attribute of the`@Bean`annotation accepts a String array for this purpose.

```
@Configuration
public
class
 AppConfig {

    
@Bean(name = { "dataSource", "subsystemA-dataSource", "subsystemB-dataSource" })
public
 DataSource dataSource() {
        
// instantiate, configure and return DataSource bean...

    }

}
```

#### Bean description

Sometimes it is helpful to provide a more detailed textual description of a bean. This can be particularly useful when beans are exposed \(perhaps via JMX\) for monitoring purposes.

To add a description to a`@Bean`the[`@Description`](http://docs.spring.io/spring-framework/docs/4.3.11.RELEASE/javadoc-api/org/springframework/context/annotation/Description.html)annotation can be used:

```
@Configuration
public
class
 AppConfig {

    
@Bean
@Description("Provides a basic example of a bean")
public
 Foo foo() {
        
return
new
 Foo();
    }

}
```



