### 7.12.5 Composing Java-based configurations

#### Using the @Import annotation

Much as the`<import/>`element is used within Spring XML files to aid in modularizing configurations, the`@Import`annotation allows for loading`@Bean`definitions from another configuration class:

```
@Configuration
public class ConfigA {

     @Bean
    public A a() {
        return new A();
    }

}

@Configuration
@Import(ConfigA.class)
public class ConfigB {

    @Bean
    public B b() {
        return new B();
    }

}
```

Now, rather than needing to specify both`ConfigA.class`and`ConfigB.class`when instantiating the context, only`ConfigB`needs to be supplied explicitly:

```
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class);

    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
```

This approach simplifies container instantiation, as only one class needs to be dealt with, rather than requiring the developer to remember a potentially large number of`@Configuration`classes during construction.

> As of Spring Framework 4.2,`@Import`also supports references to regular component classes, analogous to the`AnnotationConfigApplicationContext.register`method. This is particularly useful if you’d like to avoid component scanning, using a few configuration classes as entry points for explicitly defining all your components. |

##### Injecting dependencies on imported @Bean definitions

The example above works, but is simplistic. In most practical scenarios, beans will have dependencies on one another across configuration classes. When using XML, this is not an issue, per se, because there is no compiler involved, and one can simply declare`ref="someBean"`and trust that Spring will work it out during container initialization. Of course, when using`@Configuration`classes, the Java compiler places constraints on the configuration model, in that references to other beans must be valid Java syntax.

Fortunately, solving this problem is simple. As[we already discussed](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-java-dependencies),`@Bean`method can have an arbitrary number of parameters describing the bean dependencies. Let’s consider a more real-world scenario with several`@Configuration`classes, each depending on beans declared in the others:

```
@Configuration
public class ServiceConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }

}

@Configuration
public class RepositoryConfig {

    @Bean
    public AccountRepository accountRepository(DataSource dataSource) {
        return new JdbcAccountRepository(dataSource);
    }

}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

There is another way to achieve the same result. Remember that`@Configuration`classes are ultimately just another bean in the container: This means that they can take advantage of`@Autowired`and`@Value`injection etc just like any other bean!

> Make sure that the dependencies you inject that way are of the simplest kind only.`@Configuration`classes are processed quite early during the initialization of the context and forcing a dependency to be injected this way may lead to unexpected early initialization. Whenever possible, resort to parameter-based injection as in the example above.Also, be particularly careful with`BeanPostProcessor`and`BeanFactoryPostProcessor`definitions via`@Bean`. Those should usually be declared as`static @Bean`methods, not triggering the instantiation of their containing configuration class. Otherwise,`@Autowired`and`@Value`won’t work on the configuration class itself since it is being created as a bean instance too early. |

```
@Configuration
public class ServiceConfig {

    @Autowired
    private AccountRepository accountRepository;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(accountRepository);
    }

}

@Configuration
public class RepositoryConfig {

    private final DataSource dataSource;

    @Autowired
    public RepositoryConfig(DataSource dataSource) {
        this.dataSource = dataSource;
    }

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

}

@Configuration
@Import({ServiceConfig.class, RepositoryConfig.class})
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return new DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    // everything wires up across configuration classes...
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

> Constructor injection in`@Configuration`classes is only supported as of Spring Framework 4.3. Note also that there is no need to specify`@Autowired`if the target bean defines only one constructor; in the example above,`@Autowired`is not necessary on the`RepositoryConfig`constructor. |

In the scenario above, using`@Autowired`works well and provides the desired modularity, but determining exactly where the autowired bean definitions are declared is still somewhat ambiguous. For example, as a developer looking at`ServiceConfig`, how do you know exactly where the`@Autowired AccountRepository`bean is declared? It’s not explicit in the code, and this may be just fine. Remember that the[Spring Tool Suite](https://spring.io/tools/sts)provides tooling that can render graphs showing how everything is wired up - that may be all you need. Also, your Java IDE can easily find all declarations and uses of the`AccountRepository`type, and will quickly show you the location of`@Bean`methods that return that type.

In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one`@Configuration`class to another, consider autowiring the configuration classes themselves:

```
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        // navigate 'through' the config class to the @Bean method!
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }

}
```

In the situation above, it is completely explicit where`AccountRepository`is defined. However,`ServiceConfig`is now tightly coupled to`RepositoryConfig`; that’s the tradeoff. This tight coupling can be somewhat mitigated by using interface-based or abstract class-based`@Configuration`classes. Consider the following:

```
@Configuration
public class ServiceConfig {

    @Autowired
    private RepositoryConfig repositoryConfig;

    @Bean
    public TransferService transferService() {
        return new TransferServiceImpl(repositoryConfig.accountRepository());
    }
}

@Configuration
public interface RepositoryConfig {

    @Bean
    AccountRepository accountRepository();

}

@Configuration
public class DefaultRepositoryConfig implements RepositoryConfig {

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(...);
    }

}

@Configuration
@Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!
public class SystemTestConfig {

    @Bean
    public DataSource dataSource() {
        // return DataSource
    }

}

public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    transferService.transfer(100.00, "A123", "C456");
}
```

Now`ServiceConfig`is loosely coupled with respect to the concrete`DefaultRepositoryConfig`, and built-in IDE tooling is still useful: it will be easy for the developer to get a type hierarchy of`RepositoryConfig`implementations. In this way, navigating`@Configuration`classes and their dependencies becomes no different than the usual process of navigating interface-based code.

#### Conditionally include @Configuration classes or @Bean methods

It is often useful to conditionally enable or disable a complete`@Configuration`class, or even individual`@Bean`methods, based on some arbitrary system state. One common example of this is to use the`@Profile`annotation to activate beans only when a specific profile has been enabled in the Spring`Environment`\(see[Section 7.13.1, “Bean definition profiles”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-definition-profiles)for details\).

The`@Profile`annotation is actually implemented using a much more flexible annotation called[`@Conditional`](http://docs.spring.io/spring-framework/docs/4.3.11.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html). The`@Conditional`annotation indicates specific`org.springframework.context.annotation.Condition`implementations that should be consulted before a`@Bean`is registered.

Implementations of the`Condition`interface simply provide a`matches(…​)`method that returns`true`or`false`. For example, here is the actual`Condition`implementation used for`@Profile`:

```
@Override
public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
    if (context.getEnvironment() != null) {
        // Read the @Profile annotation attributes
        MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName());
        if (attrs != null) {
            for (Object value : attrs.get("value")) {
                if (context.getEnvironment().acceptsProfiles(((String[]) value))) {
                    return true;
                }
            }
            return false;
        }
    }
    return true;
}
```

See the[`@Conditional`javadocs](http://docs.spring.io/spring-framework/docs/4.3.11.RELEASE/javadoc-api/org/springframework/context/annotation/Conditional.html)for more detail.

#### Combining Java and XML configuration

Spring’s`@Configuration`class support does not aim to be a 100% complete replacement for Spring XML. Some facilities such as Spring XML namespaces remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an "XML-centric" way using, for example,`ClassPathXmlApplicationContext`, or in a "Java-centric" fashion using`AnnotationConfigApplicationContext`and the`@ImportResource`annotation to import XML as needed.

##### XML-centric use of @Configuration classes

It may be preferable to bootstrap the Spring container from XML and include`@Configuration`classes in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it will be easier to create`@Configuration`classes on an as-needed basis and include them from the existing XML files. Below you’ll find the options for using`@Configuration`classes in this kind of "XML-centric" situation.

Remember that`@Configuration`classes are ultimately just bean definitions in the container. In this example, we create a`@Configuration`class named`AppConfig`and include it within`system-test-config.xml`as a`<bean/>`definition. Because`<context:annotation-config/>`is switched on, the container will recognize the`@Configuration`annotation and process the`@Bean`methods declared in`AppConfig`properly.

```
@Configuration
public class AppConfig {

    @Autowired
    private DataSource dataSource;

    @Bean
    public AccountRepository accountRepository() {
        return new JdbcAccountRepository(dataSource);
    }

    @Bean
    public TransferService transferService() {
        return new TransferService(accountRepository());
    }

}
```

**system-test-config.xml**:

```
<beans>
    <!-- enable processing of annotations such as @Autowired and @Configuration -->
    <context:annotation-config/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="com.acme.AppConfig"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

**jdbc.properties**:

```
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
```

```
public static void main(String[] args) {
    ApplicationContext ctx = new ClassPathXmlApplicationContext("classpath:/com/acme/system-test-config.xml");
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```

> In`system-test-config.xml`above, the`AppConfig<bean/>`does not declare an`id`element. While it would be acceptable to do so, it is unnecessary given that no other bean will ever refer to it, and it is unlikely that it will be explicitly fetched from the container by name. Likewise with the`DataSource`bean - it is only ever autowired by type, so an explicit bean`id`is not strictly required. |

Because`@Configuration`is meta-annotated with`@Component`,`@Configuration`-annotated classes are automatically candidates for component scanning. Using the same scenario as above, we can redefine`system-test-config.xml`to take advantage of component-scanning. Note that in this case, we don’t need to explicitly declare`<context:annotation-config/>`, because`<context:component-scan/>`enables the same functionality.

**system-test-config.xml**:

```
<beans>
    <!-- picks up and registers AppConfig as a bean definition -->
    <context:component-scan base-package="com.acme"/>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>

    <bean class="org.springframework.jdbc.datasource.DriverManagerDataSource">
        <property name="url" value="${jdbc.url}"/>
        <property name="username" value="${jdbc.username}"/>
        <property name="password" value="${jdbc.password}"/>
    </bean>
</beans>
```

##### @Configuration class-centric use of XML with @ImportResource

In applications where`@Configuration`classes are the primary mechanism for configuring the container, it will still likely be necessary to use at least some XML. In these scenarios, simply use`@ImportResource`and define only as much XML as is needed. Doing so achieves a "Java-centric" approach to configuring the container and keeps XML to a bare minimum.

```
@Configuration
@ImportResource("classpath:/com/acme/properties-config.xml")
public class AppConfig {

    @Value("${jdbc.url}")
    private String url;

    @Value("${jdbc.username}")
    private String username;

    @Value("${jdbc.password}")
    private String password;

    @Bean
    public DataSource dataSource() {
        return new DriverManagerDataSource(url, username, password);
    }

}
```

```
properties-config.xml
<beans>
    <context:property-placeholder location="classpath:/com/acme/jdbc.properties"/>
</beans>
```

```
jdbc.properties
jdbc.url=jdbc:hsqldb:hsql://localhost/xdb
jdbc.username=sa
jdbc.password=
```

```
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    TransferService transferService = ctx.getBean(TransferService.class);
    // ...
}
```



