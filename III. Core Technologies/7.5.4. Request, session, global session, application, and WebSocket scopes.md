### 7.5.4 Request, session, global session, application, and WebSocket scopes

The`request`,`session`,`globalSession`,`application`, and`websocket`scopes are_only_available if you use a web-aware Spring`ApplicationContext`implementation \(such as`XmlWebApplicationContext`\). If you use these scopes with regular Spring IoC containers such as the`ClassPathXmlApplicationContext`, an`IllegalStateException`will be thrown complaining about an unknown bean scope.

#### Initial web configuration

To support the scoping of beans at the`request`,`session`,`globalSession`,`application`, and`websocket`levels \(web-scoped beans\), some minor initial configuration is required before you define your beans. \(This initial setup is_not_required for the standard scopes,`singleton`and`prototype`.\)

How you accomplish this initial setup depends on your particular Servlet environment.

If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring`DispatcherServlet`or`DispatcherPortlet`, then no special setup is necessary:`DispatcherServlet`and`DispatcherPortlet`already expose all relevant state.

If you use a Servlet 2.5 web container, with requests processed outside of Spring’s`DispatcherServlet`\(for example, when using JSF or Struts\), you need to register the`org.springframework.web.context.request.RequestContextListenerServletRequestListener`. For Servlet 3.0+, this can be done programmatically via the`WebApplicationInitializer`interface. Alternatively, or for older containers, add the following declaration to your web application’s`web.xml`file:

```
<web-app>
    ...
    <listener>
        <listener-class>
            org.springframework.web.context.request.RequestContextListener
        </listener-class>
    </listener>
    ...
</web-app>
```

Alternatively, if there are issues with your listener setup, consider using Spring’s`RequestContextFilter`. The filter mapping depends on the surrounding web application configuration, so you have to change it as appropriate.

```
<web-app>
    ...
    <filter>
        <filter-name>requestContextFilter</filter-name>
        <filter-class>org.springframework.web.filter.RequestContextFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>requestContextFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>
    ...
</web-app>
```

`DispatcherServlet`,`RequestContextListener`, and`RequestContextFilter`all do exactly the same thing, namely bind the HTTP request object to the`Thread`that is servicing that request. This makes beans that are request- and session-scoped available further down the call chain.

#### Request scope

Consider the following XML configuration for a bean definition:

```
<bean id="loginAction" class="com.foo.LoginAction" scope="request"/>
```

The Spring container creates a new instance of the`LoginAction`bean by using the`loginAction`bean definition for each and every HTTP request. That is, the`loginAction`bean is scoped at the HTTP request level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same`loginAction`bean definition will not see these changes in state; they are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded.

When using annotation-driven components or Java Config, the`@RequestScope`annotation can be used to assign a component to the`request`scope.

```
@RequestScope
@Component
public class LoginAction {
    // ...
}
```

#### Session scope

Consider the following XML configuration for a bean definition:

```
<bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/>
```

The Spring container creates a new instance of the`UserPreferences`bean by using the`userPreferences`bean definition for the lifetime of a single HTTP`Session`. In other words, the`userPreferences`bean is effectively scoped at the HTTP`Session`level. As with`request-scoped`beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP`Session`instances that are also using instances created from the same`userPreferences`bean definition do not see these changes in state, because they are particular to an individual HTTP`Session`. When the HTTP`Session`is eventually discarded, the bean that is scoped to that particular HTTP`Session`is also discarded.

When using annotation-driven components or Java Config, the`@SessionScope`annotation can be used to assign a component to the`session`scope.

```
@SessionScope
@Component
public class UserPreferences {
    // ...
}
```

#### Global session scope

Consider the following bean definition:

```
<bean id="userPreferences" class="com.foo.UserPreferences" scope="globalSession"/>
```

The`globalSession`scope is similar to the standard HTTP`Session`scope \([described above](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes-session)\), and applies only in the context of portlet-based web applications. The portlet specification defines the notion of a global`Session`that is shared among all portlets that make up a single portlet web application. Beans defined at the`globalSession`scope are scoped \(or bound\) to the lifetime of the global portlet`Session`.

If you write a standard Servlet-based web application and you define one or more beans as having`globalSession`scope, the standard HTTP`Session`scope is used, and no error is raised.

#### Application scope

Consider the following XML configuration for a bean definition:

```
<bean id="appPreferences" class="com.foo.AppPreferences" scope="application"/>
```

The Spring container creates a new instance of the`AppPreferences`bean by using the`appPreferences`bean definition once for the entire web application. That is, the`appPreferences`bean is scoped at the`ServletContext`level, stored as a regular`ServletContext`attribute. This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per`ServletContext`, not per Spring 'ApplicationContext' \(for which there may be several in any given web application\), and it is actually exposed and therefore visible as a`ServletContext`attribute.

When using annotation-driven components or Java Config, the`@ApplicationScope`annotation can be used to assign a component to the`application`scope.

```
@ApplicationScope
@Component
public class AppPreferences {
    // ...
}
```

#### Scoped beans as dependencies

The Spring IoC container manages not only the instantiation of your objects \(beans\), but also the wiring up of collaborators \(or dependencies\). If you want to inject \(for example\) an HTTP request scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real target object from the relevant scope \(such as an HTTP request\) and delegate method calls onto the real object.

> You may also use`<aop:scoped-proxy/>`between beans that are scoped as`singleton`, with the reference then going through an intermediate proxy that is serializable and therefore able to re-obtain the target singleton bean on deserialization.When declaring`<aop:scoped-proxy/>`against a bean of scope`prototype`, every method call on the shared proxy will lead to the creation of a new target instance which the call is then being forwarded to.Also, scoped proxies are not the only way to access beans from shorter scopes in a lifecycle-safe fashion. You may also simply declare your injection point \(i.e. the constructor/setter argument or autowired field\) as`ObjectFactory<MyTargetBean>`, allowing for a`getObject()`call to retrieve the current instance on demand every time it is needed - without holding on to the instance or storing it separately.The JSR-330 variant of this is called`Provider`, used with a`Provider<MyTargetBean>`declaration and a corresponding`get()`call for every retrieval attempt. See[here](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-standard-annotations)for more details on JSR-330 overall. |

The configuration in the following example is only one line, but it is important to understand the "why" as well as the "how" behind it.

```
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xmlns:aop="http://www.springframework.org/schema/aop"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- an HTTP Session-scoped bean exposed as a proxy -->
    <bean id="userPreferences" class="com.foo.UserPreferences" scope="session">
        <!-- instructs the container to proxy the surrounding bean -->
        <aop:scoped-proxy/>
    </bean>

    <!-- a singleton-scoped bean injected with a proxy to the above bean -->
    <bean id="userService" class="com.foo.SimpleUserService">
        <!-- a reference to the proxied userPreferences bean -->
        <property name="userPreferences" ref="userPreferences"/>
    </bean>
</beans>
```

To create such a proxy, you insert a child`<aop:scoped-proxy/>`element into a scoped bean definition \(see[the section called “Choosing the type of proxy to create”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-scopes-other-injection-proxies)and[Chapter 41,XML Schema-based configuration](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#xsd-configuration)\). Why do definitions of beans scoped at the`request`,`session`,`globalSession`and custom-scope levels require the`<aop:scoped-proxy/>`element? Let’s examine the following singleton bean definition and contrast it with what you need to define for the aforementioned scopes \(note that the following`userPreferences`bean definition as it stands is_incomplete_\).

```
<bean id="userPreferences" class="com.foo.UserPreferences" scope="session"/>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

In the preceding example, the singleton bean`userManager`is injected with a reference to the HTTP`Session`-scoped bean`userPreferences`. The salient point here is that the`userManager`bean is a singleton: it will be instantiated_exactly once_per container, and its dependencies \(in this case only one, the`userPreferences`bean\) are also injected only once. This means that the`userManager`bean will only operate on the exact same`userPreferences`object, that is, the one that it was originally injected with.

This is_not_the behavior you want when injecting a shorter-lived scoped bean into a longer-lived scoped bean, for example injecting an HTTP`Session`-scoped collaborating bean as a dependency into singleton bean. Rather, you need a single`userManager`object, and for the lifetime of an HTTP`Session`, you need a`userPreferences`object that is specific to said HTTP`Session`. Thus the container creates an object that exposes the exact same public interface as the`UserPreferences`class \(ideally an object that_is a_`UserPreferences`instance\) which can fetch the real`UserPreferences`object from the scoping mechanism \(HTTP request,`Session`, etc.\). The container injects this proxy object into the`userManager`bean, which is unaware that this`UserPreferences`reference is a proxy. In this example, when a`UserManager`instance invokes a method on the dependency-injected`UserPreferences`object, it actually is invoking a method on the proxy. The proxy then fetches the real`UserPreferences`object from \(in this case\) the HTTP`Session`, and delegates the method invocation onto the retrieved real`UserPreferences`object.

Thus you need the following, correct and complete, configuration when injecting`request-`,`session-`, and`globalSession-scoped`beans into collaborating objects:

```
<bean id="userPreferences" class="com.foo.UserPreferences" scope="session">
    <aop:scoped-proxy/>
</bean>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

##### Choosing the type of proxy to create

By default, when the Spring container creates a proxy for a bean that is marked up with the`<aop:scoped-proxy/>`element,_a CGLIB-based class proxy is created_.

> CGLIB proxies only intercept public method calls! Do not call non-public methods on such a proxy; they will not be delegated to the actual scoped target object. |

Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying`false`for the value of the`proxy-target-class`attribute of the`<aop:scoped-proxy/>`element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to effect such proxying. However, it also means that the class of the scoped bean must implement at least one interface, and_that all_collaborators into which the scoped bean is injected must reference the bean through one of its interfaces.

```
<!-- DefaultUserPreferences implements the UserPreferences interface -->
<bean id="userPreferences" class="com.foo.DefaultUserPreferences" scope="session">
    <aop:scoped-proxy proxy-target-class="false"/>
</bean>

<bean id="userManager" class="com.foo.UserManager">
    <property name="userPreferences" ref="userPreferences"/>
</bean>
```

For more detailed information about choosing class-based or interface-based proxying, see[Section 11.6, “Proxying mechanisms”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#aop-proxying).

