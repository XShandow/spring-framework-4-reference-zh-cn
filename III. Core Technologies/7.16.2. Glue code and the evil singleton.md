### 7.16.2 Glue code and the evil singleton

粘合的代码和错误的单例

It is best to write most application code in a dependency-injection \(DI\) style, where that code is served out of a Spring IoC container, has its own dependencies supplied by the container when it is created, and is completely unaware of the container. However, for the small glue layers of code that are sometimes needed to tie other code together, you sometimes need a singleton \(or quasi-singleton\) style access to a Spring IoC container. For example, third-party code may try to construct new objects directly \(`Class.forName()`style\), without the ability to get these objects out of a Spring IoC container.If the object constructed by the third-party code is a small stub or proxy, which then uses a singleton style access to a Spring IoC container to get a real object to delegate to, then inversion of control has still been achieved for the majority of the code \(the object coming out of the container\). Thus most code is still unaware of the container or how it is accessed, and remains decoupled from other code, with all ensuing benefits. EJBs may also use this stub/proxy approach to delegate to a plain Java implementation object, retrieved from a Spring IoC container. While the Spring IoC container itself ideally does not have to be a singleton, it may be unrealistic in terms of memory usage or initialization times \(when using beans in the Spring IoC container such as a Hibernate`SessionFactory`\) for each bean to use its own, non-singleton Spring IoC container.  
最好将大部分应用代码实现成依赖注入的方式，当这些代码在spring的ioc容器外部时，有独立的依赖通过容器当他们创建的时候并且没有意识到容器的存在。然而，对于小的粘合层代码有时需要和其他代码耦合，你有时需要单例（或准单例）风格来访问spring的ioc容器。例如，第三方代码或许视图直接创建一个新的object（使用Class.forName的形式），不在从spring的ioc容器中获得这些object。如果通过第三方代码创建的object是代理使用单例的风格访问spring的ioc容器来获得被委托的真正object，那么反转注入风格依然是代码的重要部分（object来源自容器外）。大部分代码依然不知道容器的存在及他们是如何被访问的，并且和其他的代码是解耦的，有很多的好处。EJB可以使用stub或代理访问普通的Java实现object，从spring的ioc容器中获得。spring的ioc容器理想上不是必须是单例的，对于内存的使用是不现实或初始化次数（当在spring的ioc容器中施一公类似于Hibernate的SessionFactory），对于每个bean使用非单例的spring的ioc容器。

Looking up the application context in a service locator style is sometimes the only option for accessing shared Spring-managed components, such as in an EJB 2.1 environment, or when you want to share a single ApplicationContext as a parent to WebApplicationContexts across WAR files. In this case you should look into using the utility class[`ContextSingletonBeanFactoryLocator`](http://docs.spring.io/spring-framework/docs/4.3.11.RELEASE/javadoc-api/org/springframework/context/access/ContextSingletonBeanFactoryLocator.html)locator that is described in this[Spring team blog entry](https://spring.io/blog/2007/06/11/using-a-shared-parent-application-context-in-a-multi-war-spring-application/).  
查看应用上下文在服务定位器模式在有时是唯一的选项用于访问spring管理的组件，例如在EJB2.1环境中或当你希望共享一个单独的ApplicationContext作为一个WebApplicationContexts的父类，通过WAR文件。在这种情况你应该使用单元类ContextSingletonBeanFactoryLocator定位在spring的小组博客中讨论的。

---

[\[1\]](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#d5e1827)See[Background](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#background-ioc)

[\[2\]](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#d5e2672)See[Section 7.4.1, “Dependency Injection”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-collaborators)

