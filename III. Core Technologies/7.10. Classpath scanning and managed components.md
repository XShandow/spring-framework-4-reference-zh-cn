## 7.10 Classpath scanning and managed components

Most examples in this chapter use XML to specify the configuration metadata that produces each`BeanDefinition`within the Spring container. The previous section \([Section 7.9, “Annotation-based container configuration”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-annotation-config)\) demonstrates how to provide a lot of the configuration metadata through source-level annotations. Even in those examples, however, the "base" bean definitions are explicitly defined in the XML file, while the annotations only drive the dependency injection. This section describes an option for implicitly detecting the_candidate components_by scanning the classpath. Candidate components are classes that match against a filter criteria and have a corresponding bean definition registered with the container. This removes the need to use XML to perform bean registration; instead you can use annotations \(for example`@Component`\), AspectJ type expressions, or your own custom filter criteria to select which classes will have bean definitions registered with the container.

> Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files. Take a look at the`@Configuration`,`@Bean`,`@Import`, and`@DependsOn`annotations for examples of how to use these new features. |



