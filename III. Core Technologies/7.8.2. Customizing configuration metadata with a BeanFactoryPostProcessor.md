### 7.8.2 Customizing configuration metadata with a BeanFactoryPostProcessor

The next extension point that we will look at is the`org.springframework.beans.factory.config.BeanFactoryPostProcessor`. The semantics of this interface are similar to those of the`BeanPostProcessor`, with one major difference:`BeanFactoryPostProcessor`operates on the_bean configuration metadata_; that is, the Spring IoC container allows a`BeanFactoryPostProcessor`to read the configuration metadata and potentially change it_before_the container instantiates any beans other than`BeanFactoryPostProcessor`s.

You can configure multiple`BeanFactoryPostProcessor`s, and you can control the order in which these`BeanFactoryPostProcessor`s execute by setting the`order`property. However, you can only set this property if the`BeanFactoryPostProcessor`implements the`Ordered`interface. If you write your own`BeanFactoryPostProcessor`, you should consider implementing the`Ordered`interface too. Consult the javadocs of the`BeanFactoryPostProcessor`and`Ordered`interfaces for more details.

| ![](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/note.png "\[Note\]") |
| :--- |
| If you want to change the actual bean_instances_\(i.e., the objects that are created from the configuration metadata\), then you instead need to use a`BeanPostProcessor`\(described above in[Section 7.8.1, “Customizing beans using a BeanPostProcessor”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp)\). While it is technically possible to work with bean instances within a`BeanFactoryPostProcessor`\(e.g., using`BeanFactory.getBean()`\), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects such as bypassing bean post processing.Also,`BeanFactoryPostProcessor`s are scoped_per-container_. This is only relevant if you are using container hierarchies. If you define a`BeanFactoryPostProcessor`in one container, it will_only_be applied to the bean definitions in that container. Bean definitions in one container will not be post-processed by`BeanFactoryPostProcessor`s in another container, even if both containers are part of the same hierarchy. |

A bean factory post-processor is executed automatically when it is declared inside an`ApplicationContext`, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as`PropertyOverrideConfigurer`and`PropertyPlaceholderConfigurer`. A custom`BeanFactoryPostProcessor`can also be used, for example, to register custom property editors.

An`ApplicationContext`automatically detects any beans that are deployed into it that implement the`BeanFactoryPostProcessor`interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.

| ![](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/note.png "\[Note\]") |
| :--- |
| As with`BeanPostProcessor`s , you typically do not want to configure`BeanFactoryPostProcessor`s for lazy initialization. If no other bean references a`Bean(Factory)PostProcessor`, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the`Bean(Factory)PostProcessor`will be instantiated eagerly even if you set the`default-lazy-init`attribute to`true`on the declaration of your`<beans />`element. |

#### Example: the Class name substitution PropertyPlaceholderConfigurer

You use the`PropertyPlaceholderConfigurer`to externalize property values from a bean definition in a separate file using the standard Java`Properties`format. Doing so enables the person deploying an application to customize environment-specific properties such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container.

Consider the following XML-based configuration metadata fragment, where a`DataSource`with placeholder values is defined. The example shows properties configured from an external`Properties`file. At runtime, a`PropertyPlaceholderConfigurer`is applied to the metadata that will replace some properties of the DataSource. The values to replace are specified as_placeholders_of the form`${property-name}`which follows the Ant / log4j / JSP EL style.

```
<
bean
class
=
"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"
>
<
property
name
=
"locations"
value
=
"classpath:com/foo/jdbc.properties"
/
>
<
/bean
>
<
bean
id
=
"dataSource"
destroy-method
=
"close"
class
=
"org.apache.commons.dbcp.BasicDataSource"
>
<
property
name
=
"driverClassName"
value
=
"${jdbc.driverClassName}"
/
>
<
property
name
=
"url"
value
=
"${jdbc.url}"
/
>
<
property
name
=
"username"
value
=
"${jdbc.username}"
/
>
<
property
name
=
"password"
value
=
"${jdbc.password}"
/
>
<
/bean
>
```

The actual values come from another file in the standard Java`Properties`format:

```
jdbc.driverClassName=org.hsqldb.jdbcDriver
jdbc.url=jdbc:hsqldb:hsql://production:9002
jdbc.username=sa
jdbc.password=root
```

Therefore, the string`${jdbc.username}`is replaced at runtime with the value 'sa', and the same applies for other placeholder values that match keys in the properties file. The`PropertyPlaceholderConfigurer`checks for placeholders in most properties and attributes of a bean definition. Furthermore, the placeholder prefix and suffix can be customized.

With the`context`namespace introduced in Spring 2.5, it is possible to configure property placeholders with a dedicated configuration element. One or more locations can be provided as a comma-separated list in the`location`attribute.

```
<
context:property-placeholder
location
=
"classpath:com/foo/jdbc.properties"
/
>
```

The`PropertyPlaceholderConfigurer`not only looks for properties in the`Properties`file you specify. By default it also checks against the Java`System`properties if it cannot find a property in the specified properties files. You can customize this behavior by setting the`systemPropertiesMode`property of the configurer with one of the following three supported integer values:

* _never_\(0\): Never check system properties
* _fallback_\(1\): Check system properties if not resolvable in the specified properties files. This is the default.
* _override_\(2\): Check system properties first, before trying the specified properties files. This allows system properties to override any other property source.

Consult the`PropertyPlaceholderConfigurer`javadocs for more information.

| ![](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/tip.png "\[Tip\]") |
| :--- |
| You can use the`PropertyPlaceholderConfigurer`to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. For example:&lt;beanclass="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt;&lt;propertyname="locations"&gt;&lt;value&gt;classpath:com/foo/strategy.properties&lt;/value&gt;&lt;/property&gt;&lt;propertyname="properties"&gt;&lt;value&gt;custom.strategy.class=com.foo.DefaultStrategy&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt;&lt;beanid="serviceStrategy"class="${custom.strategy.class}"/&gt;If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the`preInstantiateSingletons()`phase of an`ApplicationContext`for a non-lazy-init bean. |

#### Example: the PropertyOverrideConfigurer

The`PropertyOverrideConfigurer`, another bean factory post-processor, resembles the`PropertyPlaceholderConfigurer`, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding`Properties`file does not have an entry for a certain bean property, the default context definition is used.

Note that the bean definition is_not_aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple`PropertyOverrideConfigurer`instances that define different values for the same bean property, the last one wins, due to the overriding mechanism.

Properties file configuration lines take this format:

```
beanName.property=value
```

For example:

```
dataSource.driverClassName=com.mysql.jdbc.Driver
dataSource.url=jdbc:mysql:mydb
```

This example file can be used with a container definition that contains a bean called_dataSource_, which has_driver_and_url_properties.

Compound property names are also supported, as long as every component of the path except the final property being overridden is already non-null \(presumably initialized by the constructors\). In this example…​

```
foo.fred.bob.sammy=123
```

1. the`sammy`property of the`bob`property of the`fred`property of the`foo`bean is set to the scalar value`123`.

| ![](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/images/note.png "\[Note\]") |
| :--- |
| Specified override values are always_literal_values; they are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference. |

With the`context`namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element:

```
<
context:property-override
location
=
"classpath:override.properties"
/
>
```



