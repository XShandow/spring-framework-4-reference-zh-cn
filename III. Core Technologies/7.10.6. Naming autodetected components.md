### 7.10.6Â Naming autodetected components

When a component is autodetected as part of the scanning process, its bean name is generated by the`BeanNameGenerator`strategy known to that scanner. By default, any Spring stereotype annotation \(`@Component`,`@Repository`,`@Service`, and`@Controller`\) that contains a_name_`value`will thereby provide that name to the corresponding bean definition.

If such an annotation contains no_name_`value`or for any other detected component \(such as those discovered by custom filters\), the default bean name generator returns the uncapitalized non-qualified class name. For example, if the following two components were detected, the names would be`myMovieLister`and`movieFinderImpl`:

```
@Service("myMovieLister")
public class SimpleMovieLister {
    // ...
}
```

```
@Repository
public class MovieFinderImpl implements MovieFinder {
    // ...
}
```

> If you do not want to rely on the default bean-naming strategy, you can provide a custom bean-naming strategy. First, implement the[`BeanNameGenerator`](http://docs.spring.io/spring-framework/docs/4.3.11.RELEASE/javadoc-api/org/springframework/beans/factory/support/BeanNameGenerator.html)interface, and be sure to include a default no-arg constructor. Then, provide the fully-qualified class name when configuring the scanner: |

```
@Configuration
@ComponentScan(basePackages = "org.example", nameGenerator = MyNameGenerator.class)
public class AppConfig {
    ...
}
```

```
<beans>
    <context:component-scan base-package="org.example"
        name-generator="org.example.MyNameGenerator" />
</beans>
```

As a general rule, consider specifying the name with the annotation whenever other components may be making explicit references to it. On the other hand, the auto-generated names are adequate whenever the container is responsible for wiring.

