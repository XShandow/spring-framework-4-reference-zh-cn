### 7.10.5 Defining bean metadata within components

Spring components can also contribute bean definition metadata to the container. You do this with the same`@Bean`annotation used to define bean metadata within`@Configuration`annotated classes. Here is a simple example:

```
@Component
public class FactoryMethodComponent {

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    public void doWork() {
        // Component method implementation omitted
    }

}
```

This class is a Spring component that has application-specific code contained in its`doWork()`method. However, it also contributes a bean definition that has a factory method referring to the method`publicInstance()`. The`@Bean`annotation identifies the factory method and other bean definition properties, such as a qualifier value through the`@Qualifier`annotation. Other method level annotations that can be specified are`@Scope`,`@Lazy`, and custom qualifier annotations.

> In addition to its role for component initialization, the`@Lazy`annotation may also be placed on injection points marked with`@Autowired`or`@Inject`. In this context, it leads to the injection of a lazy-resolution proxy. |

Autowired fields and methods are supported as previously discussed, with additional support for autowiring of`@Bean`methods:

```
@Component
public class FactoryMethodComponent {

    private static int i;

    @Bean
    @Qualifier("public")
    public TestBean publicInstance() {
        return new TestBean("publicInstance");
    }

    // use of a custom qualifier and autowiring of method parameters
    @Bean
    protected TestBean protectedInstance(
            @Qualifier("public") TestBean spouse,
            @Value("#{privateInstance.age}") String country) {
        TestBean tb = new TestBean("protectedInstance", 1);
        tb.setSpouse(spouse);
        tb.setCountry(country);
        return tb;
    }

    @Bean
    private TestBean privateInstance() {
        return new TestBean("privateInstance", i++);
    }

    @Bean
    @RequestScope
    public TestBean requestScopedInstance() {
        return new TestBean("requestScopedInstance", 3);
    }

}
```

The example autowires the`String`method parameter`country`to the value of the`Age`property on another bean named`privateInstance`. A Spring Expression Language element defines the value of the property through the notation`#{ <expression> }`. For`@Value`annotations, an expression resolver is preconfigured to look for bean names when resolving expression text.

As of Spring Framework 4.3, you may also declare a factory method parameter of type`InjectionPoint`\(or its more specific subclass`DependencyDescriptor`\) in order to access the requesting injection point that triggers the creation of the current bean. Note that this will only apply to the actual creation of bean instances, not to the injection of existing instances. As a consequence, this feature makes most sense for beans of prototype scope. For other scopes, the factory method will only ever see the injection point which triggered the creation of a new bean instance in the given scope: for example, the dependency that triggered the creation of a lazy singleton bean. Use the provided injection point metadata with semantic care in such scenarios.

```
@Component
public class FactoryMethodComponent {

    @Bean @Scope("prototype")
    public TestBean prototypeInstance(InjectionPoint injectionPoint) {
        return new TestBean("prototypeInstance for " + injectionPoint.getMember());
    }
}
```

The`@Bean`methods in a regular Spring component are processed differently than their counterparts inside a Spring`@Configuration`class. The difference is that`@Component`classes are not enhanced with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which invoking methods or fields within`@Bean`methods in`@Configuration`classes creates bean metadata references to collaborating objects; such methods are_not_invoked with normal Java semantics but rather go through the container in order to provide the usual lifecycle management and proxying of Spring beans even when referring to other beans via programmatic calls to`@Bean`methods. In contrast, invoking a method or field in an`@Bean`method within a plain`@Component`class_has_standard Java semantics, with no special CGLIB processing or other constraints applying.

> You may declare`@Bean`methods as`static`, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans, e.g. of type`BeanFactoryPostProcessor`or`BeanPostProcessor`, since such beans will get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point.Note that calls to static`@Bean`methods will never get intercepted by the container, not even within`@Configuration`classes \(see above\). This is due to technical limitations: CGLIB subclassing can only override non-static methods. As a consequence, a direct call to another`@Bean`method will have standard Java semantics, resulting in an independent instance being returned straight from the factory method itself.The Java language visibility of`@Bean`methods does not have an immediate impact on the resulting bean definition in Spring’s container. You may freely declare your factory methods as you see fit in non-`@Configuration`classes and also for static methods anywhere. However, regular`@Bean`methods in`@Configuration`classes need to be overridable, i.e. they must not be declared as`private`or`final`.`@Bean`methods will also be discovered on base classes of a given component or configuration class, as well as on Java 8 default methods declared in interfaces implemented by the component or configuration class. This allows for a lot of flexibility in composing complex configuration arrangements, with even multiple inheritance being possible through Java 8 default methods as of Spring 4.2.Finally, note that a single class may hold multiple`@Bean`methods for the same bean, as an arrangement of multiple factory methods to use depending on available dependencies at runtime. This is the same algorithm as for choosing the "greediest" constructor or factory method in other configuration scenarios: The variant with the largest number of satisfiable dependencies will be picked at construction time, analogous to how the container selects between multiple`@Autowired`constructors. |



