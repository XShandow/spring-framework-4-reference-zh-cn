### 7.12.2 Instantiating the Spring container using AnnotationConfigApplicationContext

The sections below document Spring’s`AnnotationConfigApplicationContext`, new in Spring 3.0. This versatile`ApplicationContext`implementation is capable of accepting not only`@Configuration`classes as input, but also plain`@Component`classes and classes annotated with JSR-330 metadata.

When`@Configuration`classes are provided as input, the`@Configuration`class itself is registered as a bean definition, and all declared`@Bean`methods within the class are also registered as bean definitions.

When`@Component`and JSR-330 classes are provided, they are registered as bean definitions, and it is assumed that DI metadata such as`@Autowired`or`@Inject`are used within those classes where necessary.

#### Simple construction

In much the same way that Spring XML files are used as input when instantiating a`ClassPathXmlApplicationContext`,`@Configuration`classes may be used as input when instantiating an`AnnotationConfigApplicationContext`. This allows for completely XML-free usage of the Spring container:

```
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

As mentioned above,`AnnotationConfigApplicationContext`is not limited to working only with`@Configuration`classes. Any`@Component`or JSR-330 annotated class may be supplied as input to the constructor. For example:

```
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

The above assumes that`MyServiceImpl`,`Dependency1`and`Dependency2`use Spring dependency injection annotations such as`@Autowired`.

#### Building the container programmatically using register\(Class&lt;?&gt;…​\)

An`AnnotationConfigApplicationContext`may be instantiated using a no-arg constructor and then configured using the`register()`method. This approach is particularly useful when programmatically building an`AnnotationConfigApplicationContext`.

```
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.register(AppConfig.class, OtherConfig.class);
    ctx.register(AdditionalConfig.class);
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

#### Enabling component scanning with scan\(String…​\)

To enable component scanning, just annotate your`@Configuration`class as follows:

```
@Configuration
@ComponentScan(basePackages = "com.acme")
public class AppConfig  {
    ...
}
```

> Experienced Spring users will be familiar with the XML declaration equivalent from Spring’s`context:`namespace


```
<beans>
    <context:component-scan base-package="com.acme"/>
</beans>
```


In the example above, the`com.acme`package will be scanned, looking for any`@Component`-annotated classes, and those classes will be registered as Spring bean definitions within the container.`AnnotationConfigApplicationContext`exposes the`scan(String…​)`method to allow for the same component-scanning functionality:

```
public static void main(String[] args) {
    AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();
    ctx.scan("com.acme");
    ctx.refresh();
    MyService myService = ctx.getBean(MyService.class);
}
```

> Remember that`@Configuration`classes are[meta-annotated](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-meta-annotations)with`@Component`, so they are candidates for component-scanning! In the example above, assuming that`AppConfig`is declared within the`com.acme`package \(or any package underneath\), it will be picked up during the call to`scan()`, and upon`refresh()`all its`@Bean`methods will be processed and registered as bean definitions within the container. |

#### Support for web applications with AnnotationConfigWebApplicationContext

A`WebApplicationContext`variant of`AnnotationConfigApplicationContext`is available with`AnnotationConfigWebApplicationContext`. This implementation may be used when configuring the Spring`ContextLoaderListener`servlet listener, Spring MVC`DispatcherServlet`, etc. What follows is a`web.xml`snippet that configures a typical Spring MVC web application. Note the use of the`contextClass`context-param and init-param:

```
<web-app>
    <!-- Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext
        instead of the default XmlWebApplicationContext -->
    <context-param>
        <param-name>contextClass</param-name>
        <param-value>
            org.springframework.web.context.support.AnnotationConfigWebApplicationContext
        </param-value>
    </context-param>

    <!-- Configuration locations must consist of one or more comma- or space-delimited
        fully-qualified @Configuration classes. Fully-qualified packages may also be
        specified for component-scanning -->
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>com.acme.AppConfig</param-value>
    </context-param>

    <!-- Bootstrap the root application context as usual using ContextLoaderListener -->
    <listener>
        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
    </listener>

    <!-- Declare a Spring MVC DispatcherServlet as usual -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
        <!-- Configure DispatcherServlet to use AnnotationConfigWebApplicationContext
            instead of the default XmlWebApplicationContext -->
        <init-param>
            <param-name>contextClass</param-name>
            <param-value>
                org.springframework.web.context.support.AnnotationConfigWebApplicationContext
            </param-value>
        </init-param>
        <!-- Again, config locations must consist of one or more comma- or space-delimited
            and fully-qualified @Configuration classes -->
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>com.acme.web.MvcConfig</param-value>
        </init-param>
    </servlet>

    <!-- map all requests for /app/* to the dispatcher servlet -->
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/app/*</url-pattern>
    </servlet-mapping>
</web-app>
```



