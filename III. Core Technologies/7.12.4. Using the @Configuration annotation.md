### 7.12.4 Using the @Configuration annotation

`@Configuration`is a class-level annotation indicating that an object is a source of bean definitions.`@Configuration`classes declare beans via public`@Bean`annotated methods. Calls to`@Bean`methods on`@Configuration`classes can also be used to define inter-bean dependencies. See[Section 7.12.1, “Basic concepts: @Bean and @Configuration”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-java-basic-concepts)for a general introduction.

#### Injecting inter-bean dependencies

When`@Bean`s have dependencies on one another, expressing that dependency is as simple as having one bean method call another:

```
@Configuration
public class AppConfig {

    @Bean
    public Foo foo() {
        return new Foo(bar());
    }

    @Bean
    public Bar bar() {
        return new Bar();
    }

}
```

In the example above, the`foo`bean receives a reference to`bar`via constructor injection.

> This method of declaring inter-bean dependencies only works when the`@Bean`method is declared within a`@Configuration`class. You cannot declare inter-bean dependencies using plain`@Component`classes. |

#### Lookup method injection

As noted earlier,[lookup method injection](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-method-injection)is an advanced feature that you should use rarely. It is useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this type of configuration provides a natural means for implementing this pattern.

```
public abstract class CommandManager {
    public Object process(Object commandState) {
        // grab a new instance of the appropriate Command interface
        Command command = createCommand();
        // set the state on the (hopefully brand new) Command instance
        command.setState(commandState);
        return command.execute();
    }

    // okay... but where is the implementation of this method?
    protected abstract Command createCommand();
}
```

Using Java-configuration support , you can create a subclass of`CommandManager`where the abstract`createCommand()`method is overridden in such a way that it looks up a new \(prototype\) command object:

```
@Bean
@Scope("prototype")
public AsyncCommand asyncCommand() {
    AsyncCommand command = new AsyncCommand();
    // inject dependencies here as required
    return command;
}

@Bean
public CommandManager commandManager() {
    // return new anonymous implementation of CommandManager with command() overridden
    // to return a new prototype Command object
    return new CommandManager() {
        protected Command createCommand() {
            return asyncCommand();
        }
    }
}
```

#### Further information about how Java-based configuration works internally

The following example shows a`@Bean`annotated method being called twice:

```
@Configuration
public class AppConfig {

    @Bean
    public ClientService clientService1() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientService clientService2() {
        ClientServiceImpl clientService = new ClientServiceImpl();
        clientService.setClientDao(clientDao());
        return clientService;
    }

    @Bean
    public ClientDao clientDao() {
        return new ClientDaoImpl();
    }

}
```

`clientDao()`has been called once in`clientService1()`and once in`clientService2()`. Since this method creates a new instance of`ClientDaoImpl`and returns it, you would normally expect having 2 instances \(one for each service\). That definitely would be problematic: in Spring, instantiated beans have a`singleton`scope by default. This is where the magic comes in: All`@Configuration`classes are subclassed at startup-time with`CGLIB`. In the subclass, the child method checks the container first for any cached \(scoped\) beans before it calls the parent method and creates a new instance. Note that as of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under`org.springframework.cglib`and included directly within the spring-core JAR.

> The behavior could be different according to the scope of your bean. We are talking about singletons here. |

> There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time, in particular that configuration classes must not be final. However, as of 4.3, any constructors are allowed on configuration classes, including the use of`@Autowired`or a single non-default constructor declaration for default injection.If you prefer to avoid any CGLIB-imposed limitations, consider declaring your`@Bean`methods on non-`@Configuration`classes, e.g. on plain`@Component`classes instead. Cross-method calls between`@Bean`methods won’t get intercepted then, so you’ll have to exclusively rely on dependency injection at the constructor or method level there. |



