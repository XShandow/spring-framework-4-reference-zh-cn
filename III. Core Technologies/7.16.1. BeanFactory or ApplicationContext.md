### 7.16.1 BeanFactory or ApplicationContext?

Use an`ApplicationContext`unless you have a good reason for not doing so.

Because the`ApplicationContext`includes all functionality of the`BeanFactory`, it is generally recommended over the`BeanFactory`, except for a few situations such as in embedded applications running on resource-constrained devices where memory consumption might be critical and a few extra kilobytes might make a difference. However, for most typical enterprise applications and systems, the`ApplicationContext`is what you will want to use. Spring makes_heavy_use of the[`BeanPostProcessor`extension point](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-factory-extension-bpp)\(to effect proxying and so on\). If you use only a plain`BeanFactory`, a fair amount of support such as transactions and AOP will not take effect, at least not without some extra steps on your part. This situation could be confusing because nothing is actually wrong with the configuration.

The following table lists features provided by the`BeanFactory`and`ApplicationContext`interfaces and implementations.



**Table 7.9. Feature Matrix**

| Feature | `BeanFactory` | `ApplicationContext` |
| :--- | :--- | :--- |
| Bean instantiation/wiring | Yes | Yes |
| Automatic`BeanPostProcessor`registration | No | Yes |
| Automatic`BeanFactoryPostProcessor`registration | No | Yes |
| Convenient`MessageSource`access \(for i18n\) | No | Yes |
| `ApplicationEvent`publication | No | Yes |

  


To explicitly register a bean post-processor with a`BeanFactory`implementation, you need to write code like this:

```
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
// populate the factory with bean definitions

// now register any needed BeanPostProcessor instances
MyBeanPostProcessor postProcessor = new MyBeanPostProcessor();
factory.addBeanPostProcessor(postProcessor);

// now start using the factory
```

To explicitly register a`BeanFactoryPostProcessor`when using a`BeanFactory`implementation, you must write code like this:

```
DefaultListableBeanFactory factory = new DefaultListableBeanFactory();
XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory);
reader.loadBeanDefinitions(new FileSystemResource("beans.xml"));

// bring in some property values from a Properties file
PropertyPlaceholderConfigurer cfg = new PropertyPlaceholderConfigurer();
cfg.setLocation(new FileSystemResource("jdbc.properties"));

// now actually do the replacement
cfg.postProcessBeanFactory(factory);
```

In both cases, the explicit registration step is inconvenient, which is one reason why the various`ApplicationContext`implementations are preferred above plain`BeanFactory`implementations in the vast majority of Spring-backed applications, especially when using`BeanFactoryPostProcessor`s and`BeanPostProcessor`s. These mechanisms implement important functionality such as property placeholder replacement and AOP.

