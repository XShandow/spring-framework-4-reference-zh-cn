### 7.10.8 Providing qualifier metadata with annotations

The`@Qualifier`annotation is discussed in[Section 7.9.4, “Fine-tuning annotation-based autowiring with qualifiers”](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-autowired-annotation-qualifiers). The examples in that section demonstrate the use of the`@Qualifier`annotation and custom qualifier annotations to provide fine-grained control when you resolve autowire candidates. Because those examples were based on XML bean definitions, the qualifier metadata was provided on the candidate bean definitions using the`qualifier`or`meta`sub-elements of the`bean`element in the XML. When relying upon classpath scanning for autodetection of components, you provide the qualifier metadata with type-level annotations on the candidate class. The following three examples demonstrate this technique:

```
@Component
@Qualifier("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```
@Component
@Genre("Action")
public class ActionMovieCatalog implements MovieCatalog {
    // ...
}
```

```
@Component
@Offline
public class CachingMovieCatalog implements MovieCatalog {
    // ...
}
```

> As with most annotation-based alternatives, keep in mind that the annotation metadata is bound to the class definition itself, while the use of XML allows for multiple beans_of the same type_to provide variations in their qualifier metadata, because that metadata is provided per-instance rather than per-class. |



