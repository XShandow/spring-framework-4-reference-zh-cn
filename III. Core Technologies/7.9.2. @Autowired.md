### 7.9.2 @Autowired

> JSR 330’s`@Inject`annotation can be used in place of Spring’s`@Autowired`annotation in the examples below. See[here](https://docs.spring.io/spring/docs/current/spring-framework-reference/htmlsingle/#beans-standard-annotations)for more details. |

You can apply the`@Autowired`annotation to constructors:

```
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...

}
```

> As of Spring Framework 4.3, the`@Autowired`constructor is no longer necessary if the target bean only defines one constructor. If several constructors are available, at least one must be annotated to teach the container which one it has to use. |

As expected, you can also apply the`@Autowired`annotation to "traditional" setter methods:

```
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...

}
```

You can also apply the annotation to methods with arbitrary names and/or multiple arguments:

```
public class MovieRecommender {

    private MovieCatalog movieCatalog;

    private CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    public void prepare(MovieCatalog movieCatalog,
            CustomerPreferenceDao customerPreferenceDao) {
        this.movieCatalog = movieCatalog;
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...

}
```

You can apply`@Autowired`to fields as well and even mix it with constructors:

```
public class MovieRecommender {

    private final CustomerPreferenceDao customerPreferenceDao;

    @Autowired
    private MovieCatalog movieCatalog;

    @Autowired
    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) {
        this.customerPreferenceDao = customerPreferenceDao;
    }

    // ...

}
```

It is also possible to provide_all_beans of a particular type from the`ApplicationContext`by adding the annotation to a field or method that expects an array of that type:

```
public class MovieRecommender {

    @Autowired
    private MovieCatalog[] movieCatalogs;

    // ...

}
```

The same applies for typed collections:

```
public class MovieRecommender {

    private Set<MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...

}
```

> Your beans can implement the`org.springframework.core.Ordered`interface or either use the`@Order`or standard`@Priority`annotation if you want items in the array or list to be sorted into a specific order. |

Even typed Maps can be autowired as long as the expected key type is`String`. The Map values will contain all beans of the expected type, and the keys will contain the corresponding bean names:

```
public class MovieRecommender {

    private Map<String, MovieCatalog> movieCatalogs;

    @Autowired
    public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) {
        this.movieCatalogs = movieCatalogs;
    }

    // ...

}
```

By default, the autowiring fails whenever_zero_candidate beans are available; the default behavior is to treat annotated methods, constructors, and fields as indicating_required_dependencies. This behavior can be changed as demonstrated below.

```
public class SimpleMovieLister {

    private MovieFinder movieFinder;

    @Autowired(required=false)
    public void setMovieFinder(MovieFinder movieFinder) {
        this.movieFinder = movieFinder;
    }

    // ...

}

```

> Only_one annotated constructor per-class_can be marked as_required_, but multiple non-required constructors can be annotated. In that case, each is considered among the candidates and Spring uses the_greediest_constructor whose dependencies can be satisfied, that is the constructor that has the largest number of arguments.`@Autowired’s`_`required`_``attribute is recommended over the `@Required``annotation. The_required_attribute indicates that the property is not required for autowiring purposes, the property is ignored if it cannot be autowired.`@Required`, on the other hand, is stronger in that it enforces the property that was set by any means supported by the container. If no value is injected, a corresponding exception is raised. |

You can also use`@Autowired`for interfaces that are well-known resolvable dependencies:`BeanFactory`,`ApplicationContext`,`Environment`,`ResourceLoader`,`ApplicationEventPublisher`, and`MessageSource`. These interfaces and their extended interfaces, such as`ConfigurableApplicationContext`or`ResourcePatternResolver`, are automatically resolved, with no special setup necessary.

```
public class MovieRecommender {

    @Autowired
    private ApplicationContext context;

    public MovieRecommender() {
    }

    // ...

}
```

> `@Autowired`,`@Inject`,`@Resource`, and`@Value`annotations are handled by Spring`BeanPostProcessor`implementations which in turn means that you_cannot_apply these annotations within your own`BeanPostProcessor`or`BeanFactoryPostProcessor`types \(if any\). These types must be 'wired up' explicitly via XML or using a Spring`@Bean`method. |



